// This file is auto-generated by generate_parser_listener.py
// DO NOT EDIT

/*
 Copyright 2019 Alain Dargelas
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 *
 * File:   AstListener.cpp
 * Author: hs
 *
 */

#include <Surelog/Common/FileSystem.h>
#include <Surelog/Common/Session.h>
#include <Surelog/Design/VObject.h>
#include <Surelog/SourceCompile/AstListener.h>
#include <Surelog/SourceCompile/SymbolTable.h>

#include <algorithm>
#include <deque>
#include <string>
#include <vector>

namespace SURELOG {
AstListener::AstListener(const AstListener& rhs)
    : m_session(rhs.m_session),
      m_objects(rhs.m_objects),
      m_count(rhs.m_count) {}

VObjectType AstListener::getNodeType(const AstNode& node) const {
  return node ? node.m_object->m_type : VObjectType::_INVALID_;
}

AstNode AstListener::getRootNode() const {
  int32_t index = static_cast<int32_t>(m_count);
  while (--index >= 0) {
    if ((m_objects[index].m_type == VObjectType::ppTop_level_rule) ||
        (m_objects[index].m_type == VObjectType::paTop_level_rule) ||
        (m_objects[index].m_type == VObjectType::paTop_level_library_rule)) {
      return AstNode(NodeId(index), &m_objects[index]);
    }
  }
  return AstNode();
}

bool AstListener::getNodeText(const AstNode& node, std::string& text) const {
  if (node && node.m_object->m_name) {
    text = m_session->getSymbolTable()->getSymbol(node.m_object->m_name);
    return true;
  }
  return false;
}

bool AstListener::getNodeText(const AstNode& node,
                              std::string_view& text) const {
  if (node && node.m_object->m_name) {
    text = m_session->getSymbolTable()->getSymbol(node.m_object->m_name);
    return true;
  }
  return false;
}

bool AstListener::getNodeFileId(const AstNode& node, PathId& fileId) const {
  if (node) {
    fileId = node.m_object->m_fileId;
    return true;
  }
  return false;
}

bool AstListener::getNodeLocation(const AstNode& node, int32_t& startLine,
                                  int32_t& startColumn, int32_t& endLine,
                                  int32_t& endColumn) const {
  if (node) {
    startLine = node.m_object->m_startLine;
    startColumn = node.m_object->m_startColumn;
    endLine = node.m_object->m_endLine;
    endColumn = node.m_object->m_endColumn;
    return true;
  }
  return false;
}

bool AstListener::getNodeStartLocation(const AstNode& node, int32_t& line,
                                       int32_t& column) const {
  int32_t endLine = 0, endColumn = 0;
  return getNodeLocation(node, line, column, endLine, endColumn);
}

bool AstListener::getNodeEndLocation(const AstNode& node, int32_t& line,
                                     int32_t& column) const {
  int32_t startLine = 0, startColumn = 0;
  return getNodeLocation(node, startLine, startColumn, line, column);
}

AstNode AstListener::getNodeParent(const AstNode& node) const {
  if (node && node.m_object->m_parent) {
    return AstNode(node.m_object->m_parent,
                   &m_objects[node.m_object->m_parent]);
  }
  return AstNode();
}

AstNode AstListener::getNodeParent(const AstNode& node,
                                   VObjectType type) const {
  if (node) {
    for (NodeId parentId = m_objects[node.m_index].m_parent; parentId;
         parentId = m_objects[parentId].m_parent) {
      if (m_objects[parentId].m_type == type) {
        return AstNode(parentId, &m_objects[parentId]);
      }
    }
  }
  return AstNode();
}

AstNode AstListener::getNodeParent(const AstNode& node,
                                   const std::set<VObjectType>& types) const {
  if (node) {
    for (NodeId parentId = m_objects[node.m_index].m_parent; parentId;
         parentId = m_objects[parentId].m_parent) {
      if (types.find(m_objects[parentId].m_type) != types.cend()) {
        return AstNode(parentId, &m_objects[parentId]);
      }
    }
  }
  return AstNode();
}

AstNode AstListener::getNodePrevSibling(const AstNode& node) const {
  if (node && node.m_object->m_parent) {
    NodeId id = m_objects[node.m_object->m_parent].m_child;
    NodeId pid;
    while (id && (id != node.m_index)) {
      pid = id;
      id = m_objects[id].m_sibling;
    }
    if (pid && (id == node.m_index)) {
      return AstNode(pid, &m_objects[pid]);
    }
  }
  return AstNode();
}

AstNode AstListener::getNodePrevSibling(const AstNode& node,
                                        VObjectType type) const {
  if (node && node.m_object->m_parent) {
    NodeId id = m_objects[node.m_object->m_parent].m_child;
    NodeId pid;
    while (id && (id != node.m_index)) {
      if (m_objects[id].m_type == type) pid = id;
      id = m_objects[id].m_sibling;
    }
    if (pid && (id == node.m_index)) {
      return AstNode(pid, &m_objects[pid]);
    }
  }
  return AstNode();
}

AstNode AstListener::getNodePrevSibling(
    const AstNode& node, const std::set<VObjectType>& types) const {
  if (node && node.m_object->m_parent) {
    NodeId id = m_objects[node.m_object->m_parent].m_child;
    NodeId pid;
    while (id && (id != node.m_index)) {
      if (types.find(m_objects[id].m_type) != types.cend()) pid = id;
      id = m_objects[id].m_sibling;
    }
    if (pid && (id == node.m_index)) {
      return AstNode(pid, &m_objects[pid]);
    }
  }
  return AstNode();
}

AstNode AstListener::getNodeNextSibling(const AstNode& node) const {
  if (node) {
    if (NodeId nid = m_objects[node.m_index].m_sibling) {
      return AstNode(nid, &m_objects[nid]);
    }
  }
  return AstNode();
}

AstNode AstListener::getNodeNextSibling(const AstNode& node,
                                        VObjectType type) const {
  if (node && node.m_object->m_sibling) {
    for (NodeId siblingId = m_objects[node.m_index].m_sibling; siblingId;
         siblingId = m_objects[siblingId].m_sibling) {
      if (m_objects[siblingId].m_type == type) {
        return AstNode(siblingId, &m_objects[siblingId]);
      }
    }
  }
  return AstNode();
}


AstNode AstListener::getNodeNextSibling(
    const AstNode& node, const std::set<VObjectType>& types) const {
  if (node && node.m_object->m_sibling) {
    for (NodeId siblingId = m_objects[node.m_index].m_sibling; siblingId;
         siblingId = m_objects[siblingId].m_sibling) {
      if (types.find(m_objects[siblingId].m_type) != types.cend()) {
        return AstNode(siblingId, &m_objects[siblingId]);
      }
    }
  }
  return AstNode();
}

bool AstListener::getNodeChildren(const AstNode& node,
                                  astnode_vector_t& children) const {
  if (!node) return false;
  if (!node.m_object->m_child) return true;

  for (NodeId id = node.m_object->m_child; id; id = m_objects[id].m_sibling) {
    children.emplace_back(id, &m_objects[id]);
  }

  return true;
}

bool AstListener::getNodeSiblings(const AstNode& node,
                                  astnode_vector_t& siblings) const {
  if (!node) return false;
  if (!node.m_object->m_parent) return true;

  const VObject& parent = m_objects[node.m_object->m_parent];

  for (NodeId id = parent.m_child; id; id = m_objects[id].m_sibling) {
    if (id != node.m_index) {
      siblings.emplace_back(id, &m_objects[id]);
    }
  }

  return true;
}

AstNode AstListener::getNodeOfTypeInTree(const AstNode& node,
                                              VObjectType type,
                                              size_t depth /* = 4 */) const {
  std::deque<std::pair<NodeId, size_t>> queue;
  queue.emplace_back(node.m_index, 0);

  while (!queue.empty()) {
    const auto& [nodeId, nodeDepth] = queue.front();

    if (m_objects[nodeId].m_type == type) {
      return AstNode(nodeId, &m_objects[nodeId]);
    }

    if (nodeDepth < depth) {
      for (NodeId childId = m_objects[nodeId].m_child; childId;
           childId = m_objects[childId].m_sibling) {
        queue.emplace_back(childId, nodeDepth + 1);
      }
    }
    queue.pop_front();
  }

  return AstNode();
}

AstNode AstListener::getNodeOfTypeInTree(
    const AstNode& node, const std::set<VObjectType>& types,
    size_t depth /* = 4 */) const {
  std::deque<std::pair<NodeId, size_t>> queue;
  queue.emplace_back(node.m_index, 0);

  while (!queue.empty()) {
    const auto& [nodeId, nodeDepth] = queue.front();

    if (types.find(m_objects[nodeId].m_type) != types.cend()) {
      return AstNode(nodeId, &m_objects[nodeId]);
    }

    if (nodeDepth < depth) {
      for (NodeId childId = m_objects[nodeId].m_child; childId;
           childId = m_objects[childId].m_sibling) {
        queue.emplace_back(childId, nodeDepth + 1);
      }
    }
    queue.pop_front();
  }

  return AstNode();
}

AstNode AstListener::getNodeChild(const AstNode& node) const {
  if (node && node.m_object->m_child) {
    return AstNode(node.m_object->m_child, &m_objects[node.m_object->m_child]);
  }
  return AstNode();
}

AstNode AstListener::getNodeChild(const AstNode& node, VObjectType type) const {
  if (node && node.m_object->m_child) {
    for (NodeId childId = m_objects[node.m_index].m_child; childId;
         childId = m_objects[childId].m_sibling) {
      if (m_objects[childId].m_type == type) {
        return AstNode(childId, &m_objects[childId]);
      }
    }
  }
  return AstNode();
}

AstNode AstListener::getNodeChild(const AstNode& node,
                                  const std::set<VObjectType>& types) const {
  if (node && node.m_object->m_child) {
    for (NodeId childId = m_objects[node.m_index].m_child; childId;
         childId = m_objects[childId].m_sibling) {
      if (types.find(m_objects[childId].m_type) != types.cend()) {
        return AstNode(childId, &m_objects[childId]);
      }
    }
  }
  return AstNode();
}

size_t AstListener::getNodeChildCount(const AstNode& node) const {
  size_t count = 0;
  if (node && node.m_object->m_child) {
    for (NodeId childId = m_objects[node.m_index].m_child; childId;
         childId = m_objects[childId].m_sibling) {
      ++count;
    }
  }
  return count;
}

size_t AstListener::getNodeChildCount(const AstNode& node,
                                      VObjectType type) const {
  size_t count = 0;
  if (node && node.m_object->m_child) {
    for (NodeId childId = m_objects[node.m_index].m_child; childId;
         childId = m_objects[childId].m_sibling) {
      if (m_objects[childId].m_type == type) ++count;
    }
  }
  return count;
}

size_t AstListener::getNodeChildCount(
    const AstNode& node, const std::set<VObjectType>& types) const {
  size_t count = 0;
  if (node && node.m_object->m_child) {
    for (NodeId childId = m_objects[node.m_index].m_child; childId;
         childId = m_objects[childId].m_sibling) {
      if (types.find(m_objects[childId].m_type) != types.cend()) ++count;
    }
  }
  return count;
}

size_t AstListener::getNodeSiblingCount(const AstNode& node) const {
  return (node && node.m_object->m_parent)
             ? (getNodeChildCount(
                    AstNode(node.m_object->m_parent,
                            &m_objects[node.m_object->m_parent])) -
                1)
             : 0;
}

size_t AstListener::getNodeSiblingCount(const AstNode& node,
                                        VObjectType type) const {
  return (node && node.m_object->m_parent)
             ? (getNodeChildCount(AstNode(node.m_object->m_parent,
                                          &m_objects[node.m_object->m_parent]),
                                  type) -
                1)
             : 0;
}

size_t AstListener::getNodeSiblingCount(
    const AstNode& node, const std::set<VObjectType>& types) const {
  return (node && node.m_object->m_parent)
             ? (getNodeChildCount(AstNode(node.m_object->m_parent,
                                          &m_objects[node.m_object->m_parent]),
                                  types) -
                1)
             : 0;
}

size_t AstListener::getNodeCountInTree(const NodeId& id) const {
  size_t count = 0;
  if (id) {
    count += 1;
    for (NodeId childId = m_objects[id].m_child; childId;
         childId = m_objects[childId].m_sibling) {
      count += getNodeCountInTree(childId);
    }
  }
  return count;
}
size_t AstListener::getNodeCountInTree(const NodeId& id,
                                       VObjectType type) const {
  size_t count = 0;
  if (id) {
    if (m_objects[id].m_type == type) count += 1;
    for (NodeId childId = m_objects[id].m_child; childId;
         childId = m_objects[childId].m_sibling) {
      count += getNodeCountInTree(childId, type);
    }
  }
  return count;
}
size_t AstListener::getNodeCountInTree(
    const NodeId& id, const std::set<VObjectType>& types) const {
  size_t count = 0;
  if (id) {
    if (types.find(m_objects[id].m_type) != types.cend()) count += 1;
    for (NodeId childId = m_objects[id].m_child; childId;
         childId = m_objects[childId].m_sibling) {
      count += getNodeCountInTree(childId, types);
    }
  }
  return count;
}

size_t AstListener::getNodeCountInTree(const AstNode& node) const {
  return getNodeCountInTree(node.m_index);
}
size_t AstListener::getNodeCountInTree(const AstNode& node,
                                       VObjectType type) const {
  return getNodeCountInTree(node.m_index, type);
}
size_t AstListener::getNodeCountInTree(
    const AstNode& node, const std::set<VObjectType>& types) const {
  return getNodeCountInTree(node.m_index, types);
}

void AstListener::enterSourceFile(Session* session, PathId fileId,
                                  const std::string& sourceText) {
  m_visited.clear();
  m_session = session;
}

void AstListener::listen(Session* session, PathId fileId,
                         const std::string& sourceText, const VObject* objects,
                         size_t count) {
  m_session = session;
  m_objects = objects;
  m_count = count;

  enterSourceFile(session, fileId, sourceText);
  if (const AstNode rootNode = getRootNode()) {
    listen(rootNode);
  }
  leaveSourceFile(fileId, sourceText);
}

void AstListener::listenChildren(const AstNode& node) {
  if (!node || !node.m_object->m_child) return;

  for (NodeId id = node.m_object->m_child; id; id = m_objects[id].m_sibling) {
    const AstNode childNode(id, &m_objects[id]);
    listen(childNode);
  }
}

void AstListener::listenSiblings(const AstNode& node) {
  if (!node || !node.m_object->m_parent) return;

  const VObject& parent = m_objects[node.m_object->m_parent];

  for (NodeId id = parent.m_child; id; id = m_objects[id].m_sibling) {
    if (id != node.m_index) {
      const AstNode siblingNode(id, &m_objects[id]);
      listen(siblingNode);
    }
  }
}

inline size_t AstListener::markVisited(const NodeId& id) {
  return id ? (m_visited.emplace(id).second ? 1 : 0) +
                  markVisited(m_objects[id].m_child) +
                  markVisited(m_objects[id].m_sibling)
            : 0;
}

inline size_t AstListener::clearVisited(const NodeId& id) {
  return id ? m_visited.erase(id) + clearVisited(m_objects[id].m_child) +
                  clearVisited(m_objects[id].m_sibling)
            : 0;
}

size_t AstListener::markVisited(const AstNode& node, bool includeSubTree) {
  size_t count = m_visited.emplace(node.m_index).second ? 1 : 0;
  if (includeSubTree) count += markChildrenVisited(node, includeSubTree);
  return count;
}
size_t AstListener::clearVisited(const AstNode& node, bool includeSubTree) {
  size_t count = m_visited.erase(node.m_index);
  if (includeSubTree) count += clearVisitedChildren(node, includeSubTree);
  return count;
}

size_t AstListener::markChildrenVisited(const AstNode& node,
                                        bool includeSubTree) {
  size_t count = 0;
  if (node && node.m_object->m_child) {
    for (NodeId childId = m_objects[node.m_index].m_child; childId;
          childId = m_objects[childId].m_sibling) {
      count += includeSubTree ? markVisited(childId)
                              : (m_visited.emplace(childId).second ? 1 : 0);
    }
  }
  return count;
}
size_t AstListener::clearVisitedChildren(const AstNode& node,
                                         bool includeSubTree) {
  size_t count = 0;
  if (node && node.m_object->m_child) {
    for (NodeId childId = m_objects[node.m_index].m_child; childId;
          childId = m_objects[childId].m_sibling) {
      count +=
          includeSubTree ? clearVisited(childId) : m_visited.erase(childId);
    }
  }
  return count;
}

// clang-format off
<PRIVATE_LISTEN_IMPLEMENTATIONS>
// clang-format on

void AstListener::listen(const AstNode& node) {
  if (!m_visited.insert(node).second) {
    return;
  }

  // clang-format off
  switch (node.m_object->m_type) {
<LISTEN_CASE_STATEMENTS>
    default: break;
  };
  // clang-format on
}
}  // namespace SURELOG
